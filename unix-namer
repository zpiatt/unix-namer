#!/usr/bin/env python3

# Unix-namer: A Unix naming convention standardizer written in python 3.
# https://github.com/zpiatt/unix-namer
#
# Copyright (C) 2023 Zac Piatt
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import os, sys, hashlib, argparse, re

def get_file_hash(filepath):
    hasher = hashlib.sha256()
    with open(filepath, 'rb') as file:
        while (chunk := file.read(4096)):
            hasher.update(chunk)
    return hasher.hexdigest()

def rename_files_and_dirs(directory, recursive, lowercase, field_separator, in_place_edit):
    if not os.path.isdir(directory):
        sys.exit(f"unix-namer: {directory}: Not a directory")

    for root, dirs, files in os.walk(directory, topdown=False):
        if not recursive and root != directory:
            continue

        for filename in files + dirs:
            old_filepath = os.path.join(root, filename)
            if lowercase:
                filename = filename.lower()
            new_filename = re.sub(r'[_\s]+', field_separator, filename.replace(" - ", "-").translate(str.maketrans("", "", "'!$^&*()[]|;~`<>{}()%")))
            new_filepath = os.path.join(root, new_filename)

            if os.path.exists(new_filepath) and os.path.abspath(old_filepath) != os.path.abspath(new_filepath):
                if os.path.isfile(old_filepath) and get_file_hash(old_filepath) == get_file_hash(new_filepath):
                    if in_place_edit:
                        os.remove(old_filepath)
                    else:
                        print(f"{old_filepath} == {new_filepath}")
                else:
                    print(f"{old_filepath} != {new_filepath}")
            else:
                if old_filepath != new_filepath:
                    if in_place_edit:
                        os.rename(old_filepath, new_filepath)
                    else:
                        print(f"{old_filepath} -> {new_filepath}")


def main():
    parser = argparse.ArgumentParser(usage='unix-namer [OPTION]... [DIR]...',
                                    description='Convert file & directory names to a Unix-friendly naming convention.',
                                    epilog='Version 1.1.1')
    parser.add_argument('directory', type=str, help='Target DIR')
    parser.add_argument('-r', '--recursive', action='store_true', help='Apply convention recursively.')
    parser.add_argument('-l', '--lowercase', action='store_true', help='Convert all names to lowercase.')
    parser.add_argument('-f', '--field-separator', metavar='', type=str, default='_', help='Specify field separator. Defaults to underscore.')
    parser.add_argument('-i', '--in-place-edit', action='store_true', help='edit filenames in place.')

    args = parser.parse_args()

    rename_files_and_dirs(args.directory, args.recursive, args.lowercase, args.field_separator, args.in_place_edit)

if __name__ == "__main__":
    main()